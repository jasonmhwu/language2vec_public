function [cv_classifications, cv_accs, partitions] = ...
    searchlight_classifier_crossval(activation_matrix, trials_to_classify, ...
                                    number_of_cv_folds, ...
                                    searchlights, ...
                                    ground_truth, ...
                                    classifier_function, ...
                                    classes, ...
                                    varargin)
% function [cv_classifications, cv_accs] = ...
%     searchlight_classifier_crossval(activation_matrix, trials_to_classify, ...
%                                     number_of_cv_folds, ...
%                                     searchlights, ...
%                                     ground_truth, ...
%                                     classifier_function)
% 
% Input: 
%   activation_matrix: a time/beta/condition x voxel activation matrix. 
%     Rows are the different times, betas, or conditions to classify, and
%     columns are voxels.  This is the format returned by
%     `assemble_betas_one_sub()`.
%   trials_to_classify: A vector with the indices of the trials (rows in
%     `activation_matrix`) to classify.
%   number_of_cv_folds: How many folds to split the data into (6 to 10 is a
%     good choice).
%   searchlights: a cell vector of searchlights (or ROIs).  The cross-validated
%     classifier accuracy will be determined for each searchlight or ROI
%     individually.  Each searchlight is a vector of the indices it contains 
%     (column indices in `activation_matrix`).  This is the format that is
%     output by `make_searchlights()`
%   ground_truth: A vector of the correct classifications (1 or 2) for each 
%     trial to classify.
%   classifier_function: See `searchlight_gnb.m` for example and input/output
%     specification.
%   varagin: Any additional arguments are passed onto the classifier function
% 
% Output
%   cv_classifications: How each trial/beta/condition is classified, according
%     to each searchlight/ROI.  This is a trial/beta/condition-by-searchlight/ROI
%     matrix with elements of 1 or 2 (corresponding to the ground truth categories).
%   cv_accuracies: A CV fold-by-searchlight/ROI matrix of accuracies in each fold for
%     each searchlight/ROI.  To get overall accuracy (assuming equal fold sizes),
%     you can do `mean(cv_accuracies, 1)`.
%   partitions: The partition struct (as generated by the Matlab built-in
%     `cvpartition`).  Has fields `training` and `test`.

% construct cv partitions.

% using leave-one-word out validation
for fold  = 1:number_of_cv_folds
    test_indices = cat(1, classes{:, fold});
    partitions.test{fold} = ismember(trials_to_classify, test_indices')';
    partitions.training{fold} = ~ismember(trials_to_classify, test_indices')';
end
% pre-allocate results
cv_classifications = zeros(length(trials_to_classify), length(searchlights));
cv_accs = zeros(number_of_cv_folds, length(searchlights));

for fold = 1:number_of_cv_folds
    fprintf('Fold %d of %d\n', fold, number_of_cv_folds);
    train_set = partitions.training{fold};
    
    % pull out training sets
    train_times_conditions = cell(1, length(unique(ground_truth)));
    for i = 1:length(unique(ground_truth))
        train_times_conditions{i} = ...
            trials_to_classify(train_set & ground_truth'==i);
    end
                              
    % pull out testing set, and corresponding ground truth
    test_set = partitions.test{fold};
    test_times = trials_to_classify(test_set);
    ground_truth_fold = ground_truth(test_set);

    [class_fold, accs_fold] = classifier_function(activation_matrix, ...
                                                  train_times_conditions, ...
                                                  test_times, ...
                                                  searchlights, ...
                                                  ground_truth_fold, ...
                                                  varargin{:});
    
    cv_classifications(test_set, :) = class_fold;
    cv_accs(fold, :) = accs_fold;
    
end